#!/usr/bin/python3
from bcc import BPF
import ctypes as ct
import json, os, subprocess, psutil
from datetime import datetime
from shutil import which
import platform
import sys

# í•„ìš”í•œ ê²½ìš° íŒŒì¼ ë””ìŠ¤í¬ë¦½í„° ì •ë¦¬ ë° í‘œì¤€ ì…ì¶œë ¥ ë¦¬ë””ë ‰ì…˜ì„ ìœ„í•œ ì»¨í…ìŠ¤íŠ¸ ê´€ë¦¬ì
class DaemonizeContext:
    def __init__(self, pid_file='/tmp/runtime_sbom_monitor.pid', stdout_file='/tmp/runtime_sbom_monitor.log', stderr_file='/tmp/runtime_sbom_monitor.log'):
        self.pid_file = pid_file
        self.stdout = open(stdout_file, 'a+')
        self.stderr = open(stderr_file, 'a+', buffering=1) # ë¼ì¸ ë²„í¼ë§ í™œì„±í™”

    def __enter__(self):
        self.cleanup_pid()
        self.write_pid()

    def __exit__(self, exc_type, exc_val, exc_tb):
        if os.path.exists(self.pid_file):
            os.remove(self.pid_file)
        self.stdout.close()
        self.stderr.close()

    def cleanup_pid(self):
        # ê¸°ì¡´ PID íŒŒì¼ ì •ë¦¬ (ì„ íƒì )
        if os.path.exists(self.pid_file):
            try:
                with open(self.pid_file, 'r') as f:
                    pid = int(f.read().strip())
                if psutil.pid_exists(pid):
                    print(f"ê²½ê³ : PID {pid}ê°€ ì´ë¯¸ ì‹¤í–‰ ì¤‘. ì¢…ë£Œ.")
                    sys.exit(1)
                os.remove(self.pid_file)
            except:
                pass

    def write_pid(self):
        with open(self.pid_file, 'w') as f:
            f.write(str(os.getpid()))

def daemonize(context_manager):
    try:
        pid = os.fork()
        if pid > 0:
            # 1ì°¨ ë¶€ëª¨ í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ
            sys.exit(0)
    except OSError as e:
        sys.stderr.write(f"1ì°¨ fork ì‹¤íŒ¨: {e}\n")
        sys.exit(1)

    # 1. ìƒˆ ì„¸ì…˜ ê·¸ë£¹ ìƒì„± (í„°ë¯¸ë„ì—ì„œ ì™„ì „íˆ ë¶„ë¦¬)
    os.setsid()

    try:
        pid = os.fork()
        if pid > 0:
            # 2ì°¨ ë¶€ëª¨ í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ
            sys.exit(0)
    except OSError as e:
        sys.stderr.write(f"2ì°¨ fork ì‹¤íŒ¨: {e}\n")
        sys.exit(1)

    # 2. ì‘ì—… ë””ë ‰í† ë¦¬ë¥¼ ë£¨íŠ¸ë¡œ ë³€ê²½
    os.chdir("/")
    # 3. íŒŒì¼ ê¶Œí•œ ë§ˆìŠ¤í¬ ì´ˆê¸°í™”
    os.umask(0)

    # 4. í‘œì¤€ ì…ì¶œë ¥ ì¬ì—°ê²°
    sys.stdin.close()
    
    # ì»¨í…ìŠ¤íŠ¸ ê´€ë¦¬ìë¥¼ ì‚¬ìš©í•˜ì—¬ PID íŒŒì¼ ë° ë¡œê·¸ íŒŒì¼ ì²˜ë¦¬
    with context_manager:
        os.dup2(context_manager.stdout.fileno(), sys.stdout.fileno())
        os.dup2(context_manager.stderr.fileno(), sys.stderr.fileno())
        # ì‹¤í–‰í•  ë©”ì¸ ë¡œì§ì„ í˜¸ì¶œ (main_loop í•¨ìˆ˜ë¡œ ë¶„ë¦¬)
        main_loop()


# eBPF ì½”ë“œ (execve ê°ì‹œ)
bpf_program_code = """
#include <uapi/linux/ptrace.h>
#include <linux/sched.h>
#include <linux/fs.h>

BPF_PERF_OUTPUT(events);
// (eBPF ì½”ë“œëŠ” ìƒëµí•˜ì§€ ì•Šê³  ê·¸ëŒ€ë¡œ ìœ ì§€)
int trace_execve(struct pt_regs *ctx, const char __user *filename) {
Â  Â  struct {
Â  Â  Â  Â  u32 pid;
Â  Â  Â  Â  char comm[TASK_COMM_LEN];
Â  Â  Â  Â  char filename[128];
Â  Â  } data = {};

Â  Â  data.pid = bpf_get_current_pid_tgid() >> 32;
Â  Â  bpf_get_current_comm(&data.comm, sizeof(data.comm));
Â  Â  bpf_probe_read_user_str(&data.filename, sizeof(data.filename), filename);

Â  Â  events.perf_submit(ctx, &data, sizeof(data));
Â  Â  return 0;
}
"""

# ì „ì—­ ë³€ìˆ˜ ì„¤ì • ë° ì´ˆê¸°í™” ë¡œì§ (main_loopì—ì„œ ì‚¬ìš©)
RUNTIME_SBOM_FILE = "cyclonedx-runtime-sbom.json"
b = BPF(text=bpf_program_code)
syscall_fnname = b.get_syscall_fnname("execve")
b.attach_kprobe(event=syscall_fnname, fn_name="trace_execve")

# (new_sbom, get_loaded_libs, run_syft, handle_event í•¨ìˆ˜ëŠ” ë‚´ìš© ë³€ê²½ ì—†ìŒ)
def new_sbom():
    return {
        "bomFormat": "CycloneDX",
        "specVersion": "1.5",
        "version": 1,
        "metadata": {
            "timestamp": datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%SZ"),
            "tools": [
                {
                    "vendor": "custom",
                    "name": "runtime-monitor",
                    "version": "1.0"
                }
            ],
            "component": {
                "type": "application",
                "name": "runtime-monitor",
                "version": "1.0"
            },
            "properties": [
                {"name": "host.os", "value": platform.system()},
                {"name": "host.os_version", "value": platform.version()},
                {"name": "host.kernel", "value": platform.release()},
                {"name": "host.arch", "value": platform.machine()}
            ]
        },
        "components": []
    }

def get_loaded_libs(pid: int) -> dict:
Â  Â  # ... (ê¸°ì¡´ get_loaded_libs í•¨ìˆ˜ ë‚´ìš©) ...
    libs_info = {}
    try:
        proc = psutil.Process(pid)
        for m in proc.memory_maps():
            path = getattr(m, "path", None)
            if not path or not os.path.isabs(path) or not os.path.isfile(path):
                continue
            if path in libs_info:
                continue
            libs_info[path] = "runtime"
    except Exception:
        pass
    return libs_info

def run_syft(exe_file: str, pid: int):
Â  Â  # ... (ê¸°ì¡´ run_syft í•¨ìˆ˜ ë‚´ìš©) ...
    if not which("syft"):
        print("[!] syft ë¯¸ì„¤ì¹˜: ì •ì  SBOM ìƒëµ")
        return
    timestamp = datetime.utcnow().strftime("%Y%m%dT%H%M%SZ")
    out_file = f"cyclonedx-static-sbom_{os.path.basename(exe_file)}_{pid}_{timestamp}.json"
    try:
        with open(out_file, "w", encoding="utf-8") as fout:
            subprocess.run(["syft", exe_file, "-o", "cyclonedx-json"],
                            stdout=fout, stderr=subprocess.DEVNULL, check=True, timeout=60)
        print(f"[+] Syft ì •ì  SBOM ìƒì„±ë¨ â†’ {out_file}")
    except Exception as e:
        print(f"[!] syft ì‹¤í–‰ ì‹¤íŒ¨: {e}")


# ë©”ì¸ ë£¨í”„ë¥¼ í•¨ìˆ˜ë¡œ ë¶„ë¦¬
def main_loop():
    global runtime_sbom, seen
    print(f"ğŸš€ ëŸ°íƒ€ì„ SBOM ê°ì‹œ ì‹œì‘ (PID: {os.getpid()})")

    # ê¸°ì¡´ íŒŒì¼ ìˆìœ¼ë©´ ë¶ˆëŸ¬ì˜¤ê¸°
    if os.path.exists(RUNTIME_SBOM_FILE):
        try:
            with open(RUNTIME_SBOM_FILE, "r", encoding="utf-8") as f:
                runtime_sbom = json.load(f)
        except:
            runtime_sbom = new_sbom()
    else:
        runtime_sbom = new_sbom()

    seen = set(comp["purl"] for comp in runtime_sbom.get("components", []))

    # ì´ë²¤íŠ¸ ì²˜ë¦¬
    def handle_event(cpu, data, size):
        nonlocal runtime_sbom, seen
        event = b["events"].event(data)
        proc_name = event.comm.decode("utf-8", "replace")
        exe_file = event.filename.decode("utf-8", "replace")
        pid = event.pid

        print(f"[{datetime.now().strftime('%H:%M:%S')}] [ì‹¤í–‰ ê°ì§€] {proc_name} (PID={pid}) â†’ {exe_file}")

        # ì‹¤í–‰ëœ ë°”ì´ë„ˆë¦¬ ìì²´ component
        main_purl = f"pkg:generic/{proc_name}?pid={pid}&exe={exe_file}"
        if main_purl not in seen:
            runtime_sbom["components"].append({
                "type": "application",
                "name": proc_name,
                "version": "runtime",
                "purl": main_purl
            })
            seen.add(main_purl)

        # ë¡œë“œëœ ë¼ì´ë¸ŒëŸ¬ë¦¬ë“¤ë„ ì¶”ê°€
        libs_info = get_loaded_libs(pid)
        for lib_path, version in libs_info.items():
            lib_name = os.path.basename(lib_path)
            purl = f"pkg:generic/{lib_name}?file_path={lib_path}"
            if purl not in seen:
                runtime_sbom["components"].append({
                    "type": "library",
                    "name": lib_name,
                    "version": version,
                    "purl": purl
                })
                seen.add(purl)

        # ëŸ°íƒ€ì„ SBOM ì €ì¥
        try:
            with open(RUNTIME_SBOM_FILE, "w", encoding="utf-8") as f:
                json.dump(runtime_sbom, f, indent=2, ensure_ascii=False)
            print(f" ëŸ°íƒ€ì„ SBOM ì—…ë°ì´íŠ¸ ({len(runtime_sbom['components'])} components)")
        except Exception as e:
            print(f"[!] SBOM ì €ì¥ ì‹¤íŒ¨: {e}")

        # syft ì‹¤í–‰í•´ì„œ ì •ì  SBOM ë³„ë„ ì €ì¥
        run_syft(exe_file, pid)

    # eBPF ë²„í¼ ì—°ê²°
    b["events"].open_perf_buffer(handle_event)

    # ë¬´í•œ í´ë§ ë£¨í”„
    try:
        while True:
            b.perf_buffer_poll()
    except KeyboardInterrupt:
        # ì´ ë£¨í”„ëŠ” ë°ëª¬í™”ë˜ë©´ ì¡íˆì§€ ì•ŠìŒ (ì„œë¹„ìŠ¤ ì¤‘ì§€ í•„ìš”)
        print("\nğŸ›‘ ë°ëª¬í™”ëœ í”„ë¡œì„¸ìŠ¤ì—ì„œ Ctrl+CëŠ” ë¬´ì‹œ.")
    except Exception as e:
        print(f"ì¹˜ëª…ì  ì˜¤ë¥˜ ë°œìƒ: {e}")
    finally:
        print("ğŸ›‘ ì¢…ë£Œ: ëŸ°íƒ€ì„ SBOM ì €ì¥ ì™„ë£Œ:", RUNTIME_SBOM_FILE)


if __name__ == "__main__":
    # ë°ëª¬í™” ì»¨í…ìŠ¤íŠ¸ ìƒì„±
    daemon_context = DaemonizeContext()
    
    # ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰ ì‹œ ì¸ìˆ˜ê°€ ìˆìœ¼ë©´ í¬ê·¸ë¼ìš´ë“œë¡œ ì‹¤í–‰ (ë””ë²„ê¹…ìš©)
    if len(sys.argv) > 1 and sys.argv[1].lower() == 'foreground':
        print("ğŸ’¡ í¬ê·¸ë¼ìš´ë“œ ëª¨ë“œ ì‹¤í–‰ ì¤‘ (Ctrl+Cë¡œ ì¢…ë£Œ)")
        with daemon_context: # PID ê´€ë¦¬ë§Œ í•¨
            main_loop()
    else:
        # ì¸ìˆ˜ê°€ ì—†ìœ¼ë©´ ë°±ê·¸ë¼ìš´ë“œë¡œ ë°ëª¬í™” ì‹¤í–‰
        print("ğŸ’¡ ë°±ê·¸ë¼ìš´ë“œ ë°ëª¬ìœ¼ë¡œ ì „í™˜ ì¤‘... ë¡œê·¸: /tmp/runtime_sbom_monitor.log")
        daemonize(daemon_context)
