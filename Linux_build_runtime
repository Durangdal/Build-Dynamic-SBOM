#!/usr/bin/python3
from bcc import BPF
import ctypes as ct
import json, os, subprocess, psutil
from datetime import datetime
from shutil import which
import platform
import sys

# 필요한 경우 파일 디스크립터 정리 및 표준 입출력 리디렉션을 위한 컨텍스트 관리자
class DaemonizeContext:
    def __init__(self, pid_file='/tmp/runtime_sbom_monitor.pid', stdout_file='/tmp/runtime_sbom_monitor.log', stderr_file='/tmp/runtime_sbom_monitor.log'):
        self.pid_file = pid_file
        self.stdout = open(stdout_file, 'a+')
        self.stderr = open(stderr_file, 'a+', buffering=1) # 라인 버퍼링 활성화

    def __enter__(self):
        self.cleanup_pid()
        self.write_pid()

    def __exit__(self, exc_type, exc_val, exc_tb):
        if os.path.exists(self.pid_file):
            os.remove(self.pid_file)
        self.stdout.close()
        self.stderr.close()

    def cleanup_pid(self):
        # 기존 PID 파일 정리 (선택적)
        if os.path.exists(self.pid_file):
            try:
                with open(self.pid_file, 'r') as f:
                    pid = int(f.read().strip())
                if psutil.pid_exists(pid):
                    print(f"경고: PID {pid}가 이미 실행 중. 종료.")
                    sys.exit(1)
                os.remove(self.pid_file)
            except:
                pass

    def write_pid(self):
        with open(self.pid_file, 'w') as f:
            f.write(str(os.getpid()))

def daemonize(context_manager):
    try:
        pid = os.fork()
        if pid > 0:
            # 1차 부모 프로세스 종료
            sys.exit(0)
    except OSError as e:
        sys.stderr.write(f"1차 fork 실패: {e}\n")
        sys.exit(1)

    # 1. 새 세션 그룹 생성 (터미널에서 완전히 분리)
    os.setsid()

    try:
        pid = os.fork()
        if pid > 0:
            # 2차 부모 프로세스 종료
            sys.exit(0)
    except OSError as e:
        sys.stderr.write(f"2차 fork 실패: {e}\n")
        sys.exit(1)

    # 2. 작업 디렉토리를 루트로 변경
    os.chdir("/")
    # 3. 파일 권한 마스크 초기화
    os.umask(0)

    # 4. 표준 입출력 재연결
    sys.stdin.close()
    
    # 컨텍스트 관리자를 사용하여 PID 파일 및 로그 파일 처리
    with context_manager:
        os.dup2(context_manager.stdout.fileno(), sys.stdout.fileno())
        os.dup2(context_manager.stderr.fileno(), sys.stderr.fileno())
        # 실행할 메인 로직을 호출 (main_loop 함수로 분리)
        main_loop()


# eBPF 코드 (execve 감시)
bpf_program_code = """
#include <uapi/linux/ptrace.h>
#include <linux/sched.h>
#include <linux/fs.h>

BPF_PERF_OUTPUT(events);
// (eBPF 코드는 생략하지 않고 그대로 유지)
int trace_execve(struct pt_regs *ctx, const char __user *filename) {
    struct {
        u32 pid;
        char comm[TASK_COMM_LEN];
        char filename[128];
    } data = {};

    data.pid = bpf_get_current_pid_tgid() >> 32;
    bpf_get_current_comm(&data.comm, sizeof(data.comm));
    bpf_probe_read_user_str(&data.filename, sizeof(data.filename), filename);

    events.perf_submit(ctx, &data, sizeof(data));
    return 0;
}
"""

# 전역 변수 설정 및 초기화 로직 (main_loop에서 사용)
RUNTIME_SBOM_FILE = "cyclonedx-runtime-sbom.json"
b = BPF(text=bpf_program_code)
syscall_fnname = b.get_syscall_fnname("execve")
b.attach_kprobe(event=syscall_fnname, fn_name="trace_execve")

# (new_sbom, get_loaded_libs, run_syft, handle_event 함수는 내용 변경 없음)
def new_sbom():
    return {
        "bomFormat": "CycloneDX",
        "specVersion": "1.5",
        "version": 1,
        "metadata": {
            "timestamp": datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%SZ"),
            "tools": [
                {
                    "vendor": "custom",
                    "name": "runtime-monitor",
                    "version": "1.0"
                }
            ],
            "component": {
                "type": "application",
                "name": "runtime-monitor",
                "version": "1.0"
            },
            "properties": [
                {"name": "host.os", "value": platform.system()},
                {"name": "host.os_version", "value": platform.version()},
                {"name": "host.kernel", "value": platform.release()},
                {"name": "host.arch", "value": platform.machine()}
            ]
        },
        "components": []
    }

def get_loaded_libs(pid: int) -> dict:
    # ... (기존 get_loaded_libs 함수 내용) ...
    libs_info = {}
    try:
        proc = psutil.Process(pid)
        for m in proc.memory_maps():
            path = getattr(m, "path", None)
            if not path or not os.path.isabs(path) or not os.path.isfile(path):
                continue
            if path in libs_info:
                continue
            libs_info[path] = "runtime"
    except Exception:
        pass
    return libs_info

def run_syft(exe_file: str, pid: int):
    # ... (기존 run_syft 함수 내용) ...
    if not which("syft"):
        print("[!] syft 미설치: 정적 SBOM 생략")
        return
    timestamp = datetime.utcnow().strftime("%Y%m%dT%H%M%SZ")
    out_file = f"cyclonedx-static-sbom_{os.path.basename(exe_file)}_{pid}_{timestamp}.json"
    try:
        with open(out_file, "w", encoding="utf-8") as fout:
            subprocess.run(["syft", exe_file, "-o", "cyclonedx-json"],
                            stdout=fout, stderr=subprocess.DEVNULL, check=True, timeout=60)
        print(f"[+] Syft 정적 SBOM 생성됨 → {out_file}")
    except Exception as e:
        print(f"[!] syft 실행 실패: {e}")


# 메인 루프를 함수로 분리
def main_loop():
    global runtime_sbom, seen
    print(f"🚀 런타임 SBOM 감시 시작 (PID: {os.getpid()})")

    # 기존 파일 있으면 불러오기
    if os.path.exists(RUNTIME_SBOM_FILE):
        try:
            with open(RUNTIME_SBOM_FILE, "r", encoding="utf-8") as f:
                runtime_sbom = json.load(f)
        except:
            runtime_sbom = new_sbom()
    else:
        runtime_sbom = new_sbom()

    seen = set(comp["purl"] for comp in runtime_sbom.get("components", []))

    # 이벤트 처리
    def handle_event(cpu, data, size):
        nonlocal runtime_sbom, seen
        event = b["events"].event(data)
        proc_name = event.comm.decode("utf-8", "replace")
        exe_file = event.filename.decode("utf-8", "replace")
        pid = event.pid

        print(f"[{datetime.now().strftime('%H:%M:%S')}] [실행 감지] {proc_name} (PID={pid}) → {exe_file}")

        # 실행된 바이너리 자체 component
        main_purl = f"pkg:generic/{proc_name}?pid={pid}&exe={exe_file}"
        if main_purl not in seen:
            runtime_sbom["components"].append({
                "type": "application",
                "name": proc_name,
                "version": "runtime",
                "purl": main_purl
            })
            seen.add(main_purl)

        # 로드된 라이브러리들도 추가
        libs_info = get_loaded_libs(pid)
        for lib_path, version in libs_info.items():
            lib_name = os.path.basename(lib_path)
            purl = f"pkg:generic/{lib_name}?file_path={lib_path}"
            if purl not in seen:
                runtime_sbom["components"].append({
                    "type": "library",
                    "name": lib_name,
                    "version": version,
                    "purl": purl
                })
                seen.add(purl)

        # 런타임 SBOM 저장
        try:
            with open(RUNTIME_SBOM_FILE, "w", encoding="utf-8") as f:
                json.dump(runtime_sbom, f, indent=2, ensure_ascii=False)
            print(f" 런타임 SBOM 업데이트 ({len(runtime_sbom['components'])} components)")
        except Exception as e:
            print(f"[!] SBOM 저장 실패: {e}")

        # syft 실행해서 정적 SBOM 별도 저장
        run_syft(exe_file, pid)

    # eBPF 버퍼 연결
    b["events"].open_perf_buffer(handle_event)

    # 무한 폴링 루프
    try:
        while True:
            b.perf_buffer_poll()
    except KeyboardInterrupt:
        # 이 루프는 데몬화되면 잡히지 않음 (서비스 중지 필요)
        print("\n🛑 데몬화된 프로세스에서 Ctrl+C는 무시.")
    except Exception as e:
        print(f"치명적 오류 발생: {e}")
    finally:
        print("🛑 종료: 런타임 SBOM 저장 완료:", RUNTIME_SBOM_FILE)


if __name__ == "__main__":
    # 데몬화 컨텍스트 생성
    daemon_context = DaemonizeContext()
    
    # 스크립트 실행 시 인수가 있으면 포그라운드로 실행 (디버깅용)
    if len(sys.argv) > 1 and sys.argv[1].lower() == 'foreground':
        print("💡 포그라운드 모드 실행 중 (Ctrl+C로 종료)")
        with daemon_context: # PID 관리만 함
            main_loop()
    else:
        # 인수가 없으면 백그라운드로 데몬화 실행
        print("💡 백그라운드 데몬으로 전환 중... 로그: /tmp/runtime_sbom_monitor.log")
        daemonize(daemon_context)
