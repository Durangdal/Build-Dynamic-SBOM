#!/usr/bin/python3
from bcc import BPF
import ctypes as ct
import json, os, subprocess, psutil
from datetime import datetime
from shutil import which
import platform
import sys

# í•„ìš”í•œ ê²½ìš° íŒŒì¼ ë””ìŠ¤í¬ë¦½í„° ì •ë¦¬ ë° í‘œì¤€ ì…ì¶œë ¥ ë¦¬ë””ë ‰ì…˜ì„ ìœ„í•œ ì»¨í…ìŠ¤íŠ¸ ê´€ë¦¬ì
class DaemonizeContext:
    def __init__(self, pid_file='/tmp/runtime_sbom_monitor.pid', stdout_file='/tmp/runtime_sbom_monitor.log', stderr_file='/tmp/runtime_sbom_monitor.log'):
        self.pid_file = pid_file
        self.stdout = open(stdout_file, 'a+')
        self.stderr = open(stderr_file, 'a+', buffering=1) # ë¼ì¸ ë²„í¼ë§ í™œì„±í™”

    def __enter__(self):
        self.cleanup_pid()
        self.write_pid()

    def __exit__(self, exc_type, exc_val, exc_tb):
        if os.path.exists(self.pid_file):
            os.remove(self.pid_file)
        self.stdout.close()
        self.stderr.close()

    def cleanup_pid(self):
        # ê¸°ì¡´ PID íŒŒì¼ ì •ë¦¬ (ì„ íƒì )
        if os.path.exists(self.pid_file):
            try:
                with open(self.pid_file, 'r') as f:
                    pid = int(f.read().strip())
                if psutil.pid_exists(pid):
                    print(f"ê²½ê³ : PID {pid}ê°€ ì´ë¯¸ ì‹¤í–‰ ì¤‘. ì¢…ë£Œ.")
                    sys.exit(1)
                os.remove(self.pid_file)
            except:
                pass

    def write_pid(self):
        with open(self.pid_file, 'w') as f:
            f.write(str(os.getpid()))

def daemonize(context_manager):
    try:
        pid = os.fork()
        if pid > 0:
            # 1ì°¨ ë¶€ëª¨ í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ
            sys.exit(0)
    except OSError as e:
        sys.stderr.write(f"1ì°¨ fork ì‹¤íŒ¨: {e}\n")
        sys.exit(1)

    # 1. ìƒˆ ì„¸ì…˜ ê·¸ë£¹ ìƒì„± (í„°ë¯¸ë„ì—ì„œ ì™„ì „íˆ ë¶„ë¦¬)
    os.setsid()

    try:
        pid = os.fork()
        if pid > 0:
            # 2ì°¨ ë¶€ëª¨ í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ
            sys.exit(0)
    except OSError as e:
        sys.stderr.write(f"2ì°¨ fork ì‹¤íŒ¨: {e}\n")
        sys.exit(1)

    # 2. ì‘ì—… ë””ë ‰í† ë¦¬ë¥¼ ë£¨íŠ¸ë¡œ ë³€ê²½
    os.chdir("/")
    # 3. íŒŒì¼ ê¶Œí•œ ë§ˆìŠ¤í¬ ì´ˆê¸°í™”
    os.umask(0)

    # 4. í‘œì¤€ ì…ì¶œë ¥ ì¬ì—°ê²°
    sys.stdin.close()
    
    # ì»¨í…ìŠ¤íŠ¸ ê´€ë¦¬ìë¥¼ ì‚¬ìš©í•˜ì—¬ PID íŒŒì¼ ë° ë¡œê·¸ íŒŒì¼ ì²˜ë¦¬
    with context_manager:
        os.dup2(context_manager.stdout.fileno(), sys.stdout.fileno())
        os.dup2(context_manager.stderr.fileno(), sys.stderr.fileno())
        # ì‹¤í–‰í•  ë©”ì¸ ë¡œì§ì„ í˜¸ì¶œ (main_loop í•¨ìˆ˜ë¡œ ë¶„ë¦¬)
        main_loop()


# eBPF ì½”ë“œ (execve ê°ì‹œ)
bpf_program_code = """
#include <uapi/linux/ptrace.h>
#include <linux/sched.h>
#include <linux/fs.h>

BPF_PERF_OUTPUT(events);
// (eBPF ì½”ë“œëŠ” ìƒëµí•˜ì§€ ì•Šê³  ê·¸ëŒ€ë¡œ ìœ ì§€)
int trace_execve(struct pt_regs *ctx, const char __user *filename) {
Â  Â  struct {
Â  Â  Â  Â  u32 pid;
Â  Â  Â  Â  char comm[TASK_COMM_LEN];
Â  Â  Â  Â  char filename[128];
Â  Â  } data = {};

Â  Â  data.pid = bpf_get_current_pid_tgid() >> 32;
Â  Â  bpf_get_current_comm(&data.comm, sizeof(data.comm));
Â  Â  bpf_probe_read_user_str(&data.filename, sizeof(data.filename), filename);

Â  Â  events.perf_submit(ctx, &data, sizeof(data));
Â  Â  return 0;
}
"""

# ì „ì—­ ë³€ìˆ˜ ì„¤ì • ë° ì´ˆê¸°í™” ë¡œì§ (main_loopì—ì„œ ì‚¬ìš©)
RUNTIME_SBOM_FILE = "cycloimport os
import sys
import json
import time
import subprocess
import psutil
from datetime import datetime
from shutil import which
import platform

# --- [ìœ ë‹‰ìŠ¤ ë°ëª¬í™” ë¡œì§ ì¶”ê°€] ---------------------------------------------
# macOS (Darwin)ì€ ìœ ë‹‰ìŠ¤ ê¸°ë°˜ì´ë¯€ë¡œ os.fork()ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

# ë°ëª¬í™”ì— í•„ìš”í•œ ì„¤ì • ë° ì»¨í…ìŠ¤íŠ¸ ê´€ë¦¬ì
class DaemonizeContext:
    def __init__(self, pid_file='/var/run/dtrace_sbom_monitor.pid', stdout_file='/var/log/dtrace_sbom_monitor.log', stderr_file='/var/log/dtrace_sbom_monitor.log'):
        # macOSì˜ í‘œì¤€ ë°ëª¬ ê²½ë¡œ ì‚¬ìš©
        self.pid_file = pid_file
        # stdout, stderrì„ íŒŒì¼ë¡œ ë¦¬ë””ë ‰ì…˜í•˜ê¸° ìœ„í•´ íŒŒì¼ ë””ìŠ¤í¬ë¦½í„° ìƒì„±
        self.stdout = open(stdout_file, 'a+')
        self.stderr = open(stderr_file, 'a+', buffering=1)

    def __enter__(self):
        # ë°ëª¬ì´ ì‹œìŠ¤í…œ ì„œë¹„ìŠ¤ë¡œ ì‹¤í–‰ë  ë•ŒëŠ” PID íŒŒì¼ ê´€ë¦¬ê°€ ì¤‘ìš”í•¨
        self.write_pid()

    def __exit__(self, exc_type, exc_val, exc_tb):
        # ì •ìƒ/ë¹„ì •ìƒ ì¢…ë£Œ ì‹œ PID íŒŒì¼ ì‚­ì œ
        if os.path.exists(self.pid_file):
            os.remove(self.pid_file)
        self.stdout.close()
        self.stderr.close()

    def write_pid(self):
        # PID íŒŒì¼ ì‘ì„± (sudo ê¶Œí•œ í•„ìš”)
        try:
            with open(self.pid_file, 'w') as f:
                f.write(str(os.getpid()))
        except Exception as e:
            # PID íŒŒì¼ ì“°ê¸° ì‹¤íŒ¨ ì‹œ ì—ëŸ¬ ì¶œë ¥ (ë°ëª¬í™” ì „)
            sys.stderr.write(f"ê²½ê³ : PID íŒŒì¼ ({self.pid_file}) ì“°ê¸° ì‹¤íŒ¨. ê¶Œí•œì„ í™•ì¸í•˜ì„¸ìš”: {e}\n")


def daemonize(context_manager):
    """í‘œì¤€ Unix ë°ëª¬í™” ë¡œì§"""
    try:
        pid = os.fork()
        if pid > 0:
            # 1ì°¨ ë¶€ëª¨ í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ
            sys.exit(0)
    except OSError as e:
        sys.stderr.write(f"1ì°¨ fork ì‹¤íŒ¨: {e}\n")
        sys.exit(1)

    # 1. ìƒˆ ì„¸ì…˜ ê·¸ë£¹ ìƒì„± (í„°ë¯¸ë„ì—ì„œ ì™„ì „íˆ ë¶„ë¦¬)
    os.setsid()

    try:
        pid = os.fork()
        if pid > 0:
            # 2ì°¨ ë¶€ëª¨ í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ
            sys.exit(0)
    except OSError as e:
        sys.stderr.write(f"2ì°¨ fork ì‹¤íŒ¨: {e}\n")
        sys.exit(1)

    # 2. ì‘ì—… ë””ë ‰í† ë¦¬ë¥¼ ë£¨íŠ¸ë¡œ ë³€ê²½
    os.chdir("/")
    # 3. íŒŒì¼ ê¶Œí•œ ë§ˆìŠ¤í¬ ì´ˆê¸°í™”
    os.umask(0)

    # 4. í‘œì¤€ ì…ì¶œë ¥ ì¬ì—°ê²°
    sys.stdin.close()
    
    # ì»¨í…ìŠ¤íŠ¸ ê´€ë¦¬ìë¥¼ ì‚¬ìš©í•˜ì—¬ PID íŒŒì¼ ë° ë¡œê·¸ íŒŒì¼ ì²˜ë¦¬
    with context_manager:
        # íŒŒì¼ ë””ìŠ¤í¬ë¦½í„° ì¬ì—°ê²°
        os.dup2(context_manager.stdout.fileno(), sys.stdout.fileno())
        os.dup2(context_manager.stderr.fileno(), sys.stderr.fileno())
        
        # ë©”ì¸ ë¡œì§ í˜¸ì¶œ
        monitor_dtrace() # DTrace ëª¨ë‹ˆí„°ë§ ì‹œì‘


# macOS ì „ìš© DTrace í”„ë¡œë¸Œ ìŠ¤í¬ë¦½íŠ¸
DTRACE_PROBE_SCRIPT = """
syscall::execve:entry
/pid != $target/ {
    printf("EXEC:%d:%s\\n", pid, copyinstr(arg0));
}
"""

# print("ğŸš€ ëŸ°íƒ€ì„ SBOM ê°ì‹œ ì‹œì‘ (macOS DTrace ì‚¬ìš© - sudo ê¶Œí•œ í•„ìš”)\n")

RUNTIME_SBOM_FILE = "cyclonedx-runtime-sbom.json"
# (SBOM ì´ˆê¸°í™” ë° seen ì…‹ ë¡œì§ì€ ê·¸ëŒ€ë¡œ ìœ ì§€)

# --- [ìœ í‹¸ë¦¬í‹°: íŒŒì¼ ë²„ì „ ì¶”ì¶œ] ---------------------------------------------
def get_soname_unix(filepath: str) -> str:
    # ... (ê¸°ì¡´ get_soname_unix í•¨ìˆ˜ ë‚´ìš© ìœ ì§€) ...
    try:
        if not os.path.exists(filepath):
            return "runtime"
        
        # 1. readelf (ë§Œì•½ ì„¤ì¹˜ë˜ì–´ ìˆë‹¤ë©´)
        proc = subprocess.run(["readelf", "-d", filepath], capture_output=True, text=True, timeout=1)
        if proc.stdout:
            for line in proc.stdout.splitlines():
                if "SONAME" in line and "[" in line and "]" in line:
                    return line.split("[", 1)[1].split("]", 1)[0].strip()
        
        # 2. otool -L (macOS ê¸°ë³¸ ë„êµ¬)ë¥¼ í†µí•´ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì‹ë³„ìë¥¼ ì‚¬ìš©
        proc = subprocess.run(["otool", "-L", filepath], capture_output=True, text=True, timeout=1)
        if proc.stdout:
            lines = proc.stdout.splitlines()
            if len(lines) > 1 and "dyld" not in lines[1]:
                path_part = lines[1].strip().split(' ', 1)[0]
                return os.path.basename(path_part)
            
    except Exception:
        pass
    return "runtime"

# --- [SBOM êµ¬ì¡° ë° ì´ˆê¸°í™”] ------------------------------------------------
def new_sbom():
    # ... (ê¸°ì¡´ new_sbom í•¨ìˆ˜ ë‚´ìš© ìœ ì§€) ...
    return {
        "bomFormat": "CycloneDX",
        "specVersion": "1.5",
        "version": 1,
        "metadata": {
            "timestamp": datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%SZ"),
            "tools": [
                {
                    "vendor": "custom",
                    "name": "runtime-monitor-dtrace",
                    "version": "1.0"
                }
            ],
            "component": {
                "type": "application",
                "name": "runtime-monitor-dtrace",
                "version": "1.0"
            },
            "properties": [
                {"name": "host.os", "value": platform.system()},
                {"name": "host.os_version", "value": platform.version()},
                {"name": "host.kernel", "value": platform.release()},
                {"name": "host.arch", "value": platform.machine()}
            ]
        },
        "components": []
    }

# ê¸°ì¡´ íŒŒì¼ ë¡œë“œ ë˜ëŠ” ìƒˆ SBOM ìƒì„±
if os.path.exists(RUNTIME_SBOM_FILE):
    try:
        with open(RUNTIME_SBOM_FILE, "r", encoding="utf-8") as f:
            runtime_sbom = json.load(f)
    except:
        runtime_sbom = new_sbom()
else:
    runtime_sbom = new_sbom()

seen = set(comp["purl"] for comp in runtime_sbom.get("components", []))

# --- [ë¼ì´ë¸ŒëŸ¬ë¦¬ ìˆ˜ì§‘ ë° Syft ì‹¤í–‰] -----------------------------------------
def get_loaded_libs(pid: int) -> dict:
    # ... (ê¸°ì¡´ get_loaded_libs í•¨ìˆ˜ ë‚´ìš© ìœ ì§€) ...
    libs_info = {}
    try:
        proc = psutil.Process(pid)
        for m in proc.memory_maps():
            path = getattr(m, "path", None)
            if not path or not os.path.isabs(path) or not os.path.isfile(path):
                continue
            if path in libs_info:
                continue
            
            # macOS ë²„ì „ ì¶”ì¶œ í•¨ìˆ˜ ì‚¬ìš©
            version = get_soname_unix(path)
            libs_info[path] = version
    except Exception:
        pass
    return libs_info

def run_syft(exe_file: str, pid: int):
    # ... (ê¸°ì¡´ run_syft í•¨ìˆ˜ ë‚´ìš© ìœ ì§€) ...
    if not which("syft"):
        # ë°ëª¬ í™˜ê²½ì—ì„œëŠ” print ëŒ€ì‹  ë¡œê¹… ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©í•´ì•¼ í•˜ì§€ë§Œ, ì—¬ê¸°ì„œëŠ” ì„ì‹œë¡œ print ì‚¬ìš©
        print(f"[!] syft ë¯¸ì„¤ì¹˜: ì •ì  SBOM ìƒëµ")
        return
    timestamp = datetime.utcnow().strftime("%Y%m%dT%H%M%SZ")
    out_file = f"cyclonedx-static-sbom_{os.path.basename(exe_file)}_{pid}_{timestamp}.json"
    try:
        with open(out_file, "w", encoding="utf-8") as fout:
            subprocess.run(["syft", exe_file, "-o", "cyclonedx-json"],
                           stdout=fout, stderr=subprocess.DEVNULL, check=True, timeout=60)
        print(f"[+] Syft ì •ì  SBOM ìƒì„±ë¨ â†’ {out_file}")
    except Exception as e:
        print(f"[!] syft ì‹¤í–‰ ì‹¤íŒ¨: {e}")

# --- [DTrace ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬] ------------------------------------------------
def process_dtrace_event(line: str):
    # ... (ê¸°ì¡´ process_dtrace_event í•¨ìˆ˜ ë‚´ìš© ìœ ì§€) ...
    global runtime_sbom, seen

    if line.startswith("EXEC:"):
        parts = line.strip().split(':', 2)
        if len(parts) != 3:
            return

        try:
            pid = int(parts[1])
            exe_file = parts[2]
            proc_name = os.path.basename(exe_file)

            # ë°ëª¬ í™˜ê²½ì—ì„œëŠ” ë¡œê·¸ íŒŒì¼ì— ê¸°ë¡
            print(f"[{datetime.now().strftime('%H:%M:%S')}] [ì‹¤í–‰ ê°ì§€] {proc_name} (PID={pid}) â†’ {exe_file}")

            # 1. ì‹¤í–‰ëœ ë°”ì´ë„ˆë¦¬ ìì²´ component
            main_version = get_soname_unix(exe_file)
            main_purl = f"pkg:generic/{proc_name}?pid={pid}&exe={exe_file}"
            
            if main_purl not in seen:
                runtime_sbom["components"].append({
                    "type": "application",
                    "name": proc_name,
                    "version": main_version,
                    "purl": main_purl
                })
                seen.add(main_purl)

            # 2. ë¡œë“œëœ ë¼ì´ë¸ŒëŸ¬ë¦¬ë“¤ë„ ì¶”ê°€
            libs_info = get_loaded_libs(pid)
            for lib_path, version in libs_info.items():
                lib_name = os.path.basename(lib_path)
                purl = f"pkg:generic/{lib_name}?file_path={lib_path}"
                if purl not in seen:
                    runtime_sbom["components"].append({
                        "type": "library",
                        "name": lib_name,
                        "version": version,
                        "purl": purl
                    })
                    seen.add(purl)

            # 3. ëŸ°íƒ€ì„ SBOM ì €ì¥ ë° Syft ì‹¤í–‰
            with open(RUNTIME_SBOM_FILE, "w", encoding="utf-8") as f:
                json.dump(runtime_sbom, f, indent=2, ensure_ascii=False)
            print(f"[âœ”] ëŸ°íƒ€ì„ SBOM ì—…ë°ì´íŠ¸ ({len(runtime_sbom['components'])} components)")

            run_syft(exe_file, pid)

        except Exception as e:
            # ì—ëŸ¬ ë°œìƒ ì‹œ ë¡œê·¸ íŒŒì¼ì— ê¸°ë¡
            print(f"[!] ì´ë²¤íŠ¸ ì²˜ë¦¬ ì˜¤ë¥˜: {e}", file=sys.stderr)
            pass

def monitor_dtrace():
    """DTraceë¥¼ ì„œë¸Œí”„ë¡œì„¸ìŠ¤ë¡œ ì‹¤í–‰í•˜ê³  ì‹¤ì‹œê°„ ì¶œë ¥ì„ ì½ìŒ (ë©”ì¸ ë£¨í”„)"""
    
    # DTrace ëª…ë ¹ì–´ ì‹¤í–‰: sudo ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤.
    dtrace_cmd = ["sudo", "dtrace", "-q", "-n", DTRACE_PROBE_SCRIPT]
    
    # ë°ëª¬í™” í›„ì—ëŠ” PIDê°€ ë³€ê²½ë˜ë¯€ë¡œ, ë¡œê·¸ì— í˜„ì¬ PIDë¥¼ ê¸°ë¡
    print(f"ğŸš€ DTrace ê°ì‹œ ì‹œì‘ (PID: {os.getpid()})")
    
    try:
        # Popenì„ ì‚¬ìš©í•˜ì—¬ DTrace ì¶œë ¥ì„ ìŠ¤íŠ¸ë¦¬ë°ìœ¼ë¡œ ì½ê¸°
        process = subprocess.Popen(dtrace_cmd, stdout=subprocess.PIPE, 
                                   stderr=subprocess.STDOUT, text=True, bufsize=1)
        
        # ì¶œë ¥ ë¼ì¸ë³„ë¡œ ì½ì–´ ì²˜ë¦¬
        for line in iter(process.stdout.readline, ''):
            if process.poll() is not None:
                break
            process_dtrace_event(line)
            
    except FileNotFoundError:
        print("\nâŒ ì˜¤ë¥˜: 'dtrace' ëª…ë ¹ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
        sys.exit(1)
    except Exception as e:
        print(f"\nâŒ ì¹˜ëª…ì ì¸ ì˜¤ë¥˜: {e}", file=sys.stderr)
    finally:
        if 'process' in locals() and process.poll() is None:
            process.terminate()
        print(f"\nğŸ›‘ ì¢…ë£Œ: ëŸ°íƒ€ì„ SBOM ì €ì¥ ì™„ë£Œ: {RUNTIME_SBOM_FILE}")

if __name__ == "__main__":
    if not sys.platform.startswith("darwin"):
        print("âŒ ì´ ìŠ¤í¬ë¦½íŠ¸ëŠ” macOS (Darwin) ì „ìš© DTraceë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤. ì‹¤í–‰ì„ ì¤‘ë‹¨í•©ë‹ˆë‹¤.")
        sys.exit(1)
        
    # ë°ëª¬í™” ì»¨í…ìŠ¤íŠ¸ ìƒì„±
    daemon_context = DaemonizeContext()
    
    # ì‹¤í–‰ ì‹œ ì¸ìˆ˜ê°€ ìˆìœ¼ë©´ í¬ê·¸ë¼ìš´ë“œë¡œ ì‹¤í–‰ (ë””ë²„ê¹…ìš©)
    if len(sys.argv) > 1 and sys.argv[1].lower() == 'foreground':
        print("ğŸ’¡ í¬ê·¸ë¼ìš´ë“œ ëª¨ë“œ ì‹¤í–‰ ì¤‘ (Ctrl+Cë¡œ ì¢…ë£Œ)")
        monitor_dtrace() # monitor_dtraceëŠ” ìì²´ì ìœ¼ë¡œ í„°ë¯¸ë„ ì¶œë ¥ì„ ì‚¬ìš©í•¨
    else:
        # ì¸ìˆ˜ê°€ ì—†ìœ¼ë©´ ë°±ê·¸ë¼ìš´ë“œë¡œ ë°ëª¬í™” ì‹¤í–‰
        print("ğŸ’¡ ë°±ê·¸ë¼ìš´ë“œ ë°ëª¬ìœ¼ë¡œ ì „í™˜ ì¤‘... ë¡œê·¸: /var/log/dtrace_sbom_monitor.log")
        print("âš ï¸ DTrace ì‚¬ìš©ì„ ìœ„í•´ ìŠ¤í¬ë¦½íŠ¸ë¥¼ ë°˜ë“œì‹œ sudoë¡œ ì‹¤í–‰í•´ì•¼ í•©ë‹ˆë‹¤.")
        
        # ë°ëª¬í™” ì‹¤í–‰ (monitor_dtrace í•¨ìˆ˜ê°€ ë°ëª¬ ë‚´ë¶€ì—ì„œ í˜¸ì¶œë¨)
        daemonize(daemon_context)
nedx-runtime-sbom.json"
b = BPF(text=bpf_program_code)
syscall_fnname = b.get_syscall_fnname("execve")
b.attach_kprobe(event=syscall_fnname, fn_name="trace_execve")

# (new_sbom, get_loaded_libs, run_syft, handle_event í•¨ìˆ˜ëŠ” ë‚´ìš© ë³€ê²½ ì—†ìŒ)
def new_sbom():
    return {
        "bomFormat": "CycloneDX",
        "specVersion": "1.5",
        "version": 1,
        "metadata": {
            "timestamp": datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%SZ"),
            "tools": [
                {
                    "vendor": "custom",
                    "name": "runtime-monitor",
                    "version": "1.0"
                }
            ],
            "component": {
                "type": "application",
                "name": "runtime-monitor",
                "version": "1.0"
            },
            "properties": [
                {"name": "host.os", "value": platform.system()},
                {"name": "host.os_version", "value": platform.version()},
                {"name": "host.kernel", "value": platform.release()},
                {"name": "host.arch", "value": platform.machine()}
            ]
        },
        "components": []
    }

def get_loaded_libs(pid: int) -> dict:
Â  Â  # ... (ê¸°ì¡´ get_loaded_libs í•¨ìˆ˜ ë‚´ìš©) ...
    libs_info = {}
    try:
        proc = psutil.Process(pid)
        for m in proc.memory_maps():
            path = getattr(m, "path", None)
            if not path or not os.path.isabs(path) or not os.path.isfile(path):
                continue
            if path in libs_info:
                continue
            libs_info[path] = "runtime"
    except Exception:
        pass
    return libs_info

def run_syft(exe_file: str, pid: int):
Â  Â  # ... (ê¸°ì¡´ run_syft í•¨ìˆ˜ ë‚´ìš©) ...
    if not which("syft"):
        print("[!] syft ë¯¸ì„¤ì¹˜: ì •ì  SBOM ìƒëµ")
        return
    timestamp = datetime.utcnow().strftime("%Y%m%dT%H%M%SZ")
    out_file = f"cyclonedx-static-sbom_{os.path.basename(exe_file)}_{pid}_{timestamp}.json"
    try:
        with open(out_file, "w", encoding="utf-8") as fout:
            subprocess.run(["syft", exe_file, "-o", "cyclonedx-json"],
                            stdout=fout, stderr=subprocess.DEVNULL, check=True, timeout=60)
        print(f"[+] Syft ì •ì  SBOM ìƒì„±ë¨ â†’ {out_file}")
    except Exception as e:
        print(f"[!] syft ì‹¤í–‰ ì‹¤íŒ¨: {e}")


# ë©”ì¸ ë£¨í”„ë¥¼ í•¨ìˆ˜ë¡œ ë¶„ë¦¬
def main_loop():
    global runtime_sbom, seen
    print(f"ğŸš€ ëŸ°íƒ€ì„ SBOM ê°ì‹œ ì‹œì‘ (PID: {os.getpid()})")

    # ê¸°ì¡´ íŒŒì¼ ìˆìœ¼ë©´ ë¶ˆëŸ¬ì˜¤ê¸°
    if os.path.exists(RUNTIME_SBOM_FILE):
        try:
            with open(RUNTIME_SBOM_FILE, "r", encoding="utf-8") as f:
                runtime_sbom = json.load(f)
        except:
            runtime_sbom = new_sbom()
    else:
        runtime_sbom = new_sbom()

    seen = set(comp["purl"] for comp in runtime_sbom.get("components", []))

    # ì´ë²¤íŠ¸ ì²˜ë¦¬
    def handle_event(cpu, data, size):
        nonlocal runtime_sbom, seen
        event = b["events"].event(data)
        proc_name = event.comm.decode("utf-8", "replace")
        exe_file = event.filename.decode("utf-8", "replace")
        pid = event.pid

        print(f"[{datetime.now().strftime('%H:%M:%S')}] [ì‹¤í–‰ ê°ì§€] {proc_name} (PID={pid}) â†’ {exe_file}")

        # ì‹¤í–‰ëœ ë°”ì´ë„ˆë¦¬ ìì²´ component
        main_purl = f"pkg:generic/{proc_name}?pid={pid}&exe={exe_file}"
        if main_purl not in seen:
            runtime_sbom["components"].append({
                "type": "application",
                "name": proc_name,
                "version": "runtime",
                "purl": main_purl
            })
            seen.add(main_purl)

        # ë¡œë“œëœ ë¼ì´ë¸ŒëŸ¬ë¦¬ë“¤ë„ ì¶”ê°€
        libs_info = get_loaded_libs(pid)
        for lib_path, version in libs_info.items():
            lib_name = os.path.basename(lib_path)
            purl = f"pkg:generic/{lib_name}?file_path={lib_path}"
            if purl not in seen:
                runtime_sbom["components"].append({
                    "type": "library",
                    "name": lib_name,
                    "version": version,
                    "purl": purl
                })
                seen.add(purl)

        # ëŸ°íƒ€ì„ SBOM ì €ì¥
        try:
            with open(RUNTIME_SBOM_FILE, "w", encoding="utf-8") as f:
                json.dump(runtime_sbom, f, indent=2, ensure_ascii=False)
            print(f" ëŸ°íƒ€ì„ SBOM ì—…ë°ì´íŠ¸ ({len(runtime_sbom['components'])} components)")
        except Exception as e:
            print(f"[!] SBOM ì €ì¥ ì‹¤íŒ¨: {e}")

        # syft ì‹¤í–‰í•´ì„œ ì •ì  SBOM ë³„ë„ ì €ì¥
        run_syft(exe_file, pid)

    # eBPF ë²„í¼ ì—°ê²°
    b["events"].open_perf_buffer(handle_event)

    # ë¬´í•œ í´ë§ ë£¨í”„
    try:
        while True:
            b.perf_buffer_poll()
    except KeyboardInterrupt:
        # ì´ ë£¨í”„ëŠ” ë°ëª¬í™”ë˜ë©´ ì¡íˆì§€ ì•ŠìŒ (ì„œë¹„ìŠ¤ ì¤‘ì§€ í•„ìš”)
        print("\nğŸ›‘ ë°ëª¬í™”ëœ í”„ë¡œì„¸ìŠ¤ì—ì„œ Ctrl+CëŠ” ë¬´ì‹œ.")
    except Exception as e:
        print(f"ì¹˜ëª…ì  ì˜¤ë¥˜ ë°œìƒ: {e}")
    finally:
        print("ğŸ›‘ ì¢…ë£Œ: ëŸ°íƒ€ì„ SBOM ì €ì¥ ì™„ë£Œ:", RUNTIME_SBOM_FILE)


if __name__ == "__main__":
    # ë°ëª¬í™” ì»¨í…ìŠ¤íŠ¸ ìƒì„±
    daemon_context = DaemonizeContext()
    
    # ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰ ì‹œ ì¸ìˆ˜ê°€ ìˆìœ¼ë©´ í¬ê·¸ë¼ìš´ë“œë¡œ ì‹¤í–‰ (ë””ë²„ê¹…ìš©)
    if len(sys.argv) > 1 and sys.argv[1].lower() == 'foreground':
        print("ğŸ’¡ í¬ê·¸ë¼ìš´ë“œ ëª¨ë“œ ì‹¤í–‰ ì¤‘ (Ctrl+Cë¡œ ì¢…ë£Œ)")
        with daemon_context: # PID ê´€ë¦¬ë§Œ í•¨
            main_loop()
    else:
        # ì¸ìˆ˜ê°€ ì—†ìœ¼ë©´ ë°±ê·¸ë¼ìš´ë“œë¡œ ë°ëª¬í™” ì‹¤í–‰
        print("ğŸ’¡ ë°±ê·¸ë¼ìš´ë“œ ë°ëª¬ìœ¼ë¡œ ì „í™˜ ì¤‘... ë¡œê·¸: /tmp/runtime_sbom_monitor.log")
        daemonize(daemon_context)
